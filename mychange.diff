diff --git a/Makefile b/Makefile
index 39a99d7..4ff7aa7 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_tests\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..3fe137a 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -185,5 +185,9 @@ void            virtio_disk_init(void);
 void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);
 
+
+
+void vmprint(pagetable_t);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..fef8bd2 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -681,3 +681,56 @@ procdump(void)
     printf("\n");
   }
 }
+
+
+uint64 sys_proctable() {
+  struct proc *p = myproc();
+  vmprint(p->pagetable);
+  return 0;
+}
+
+
+uint64 count_accessed_pages(pagetable_t pagetable, uint64 start_va, int sz) {
+    uint64 accessed_pages = 0;
+    pte_t *pte;
+
+    for (int i = 0; i < sz; i += PGSIZE) {
+        pte = walk(pagetable, start_va + i, 0);
+        if (pte != 0 && ((*pte) & PTE_A)) {
+            ++accessed_pages;
+            *pte ^= PTE_A;
+        }
+    }
+
+    return accessed_pages;
+}
+
+uint64 clear_accessed_bit(pagetable_t pagetable, uint64 va) {
+    pte_t *pte = walk(pagetable, va, 0);
+    if (pte != 0 && ((*pte) & PTE_A)) {
+        *pte ^= PTE_A;
+        return 1;
+    }
+    return 0;
+}
+
+uint64 sys_wasaccess() {
+    uint64 va;
+    int sz;
+    uint64 res = 0;
+
+    argaddr(0, &va);
+    argint(1, &sz);
+
+    if (sz <= 0)
+        return -1;
+
+    pagetable_t pagetable = myproc()->pagetable;
+
+    res += count_accessed_pages(pagetable, va, sz);
+
+    uint64 last_page_va = va + sz - 1;
+    res += clear_accessed_bit(pagetable, last_page_va);
+
+    return res;
+}
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..9a99833 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -344,6 +344,10 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
+
+#define PTE_A (1L << 6) 
+#define PTE_D (1L << 7) 
+
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..aaa7d12 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -102,6 +102,9 @@ extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
 
+extern uint64 sys_proctable(void);
+extern uint64 sys_wasaccess(void);
+
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
@@ -126,6 +129,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_proctable]   sys_proctable,
+[SYS_wasaccess]   sys_wasaccess,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..561f124 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+#define SYS_proctable  22
+#define SYS_wasaccess  23
\ No newline at end of file
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..13ca070 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -437,3 +437,45 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+void print_flags(uint64 pte) {
+    int A = ((pte & PTE_A) != 0);
+    int D = ((pte & PTE_D) != 0);
+    int R = ((pte & PTE_R) != 0);
+    int W = ((pte & PTE_W) != 0);
+    int X = ((pte & PTE_X) != 0);
+
+    printf("flags: A = %d, D = %d, R = %d, W = %d, X = %d\n", A, D, R, W, X);
+}
+
+void print_indent(int depth) {
+    for (int j = 0; j < depth + 1; j++)
+        printf(" ..");
+}
+
+void pgprint_recursive(pagetable_t pagetable, int depth) {
+    for (int i = 0; i < 512; i++) {
+        pte_t pte = pagetable[i];
+        if (pte & PTE_V) {
+            uint64 child = PTE2PA(pte);
+
+            print_indent(depth);
+            printf("%d pte %p; ", i, (void *)child);
+            print_flags(pte);
+
+            if (depth < 2)
+                pgprint_recursive((pagetable_t)child, depth + 1);
+        }
+    }
+}
+
+void pgprint(pagetable_t pagetable, int depth) {
+    pgprint_recursive(pagetable, depth);
+}
+
+
+
+void vmprint(pagetable_t pagetable) {
+  printf("PT %p\n", pagetable);
+  pgprint(pagetable, 0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..e567ec1 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,11 @@ char* sbrk(int);
 int sleep(int);
 int uptime(void);
 
+
+
+int proctable(void);
+int wasaccess(void*, int);
+
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..16b5239 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+
+
+entry("wasaccess");
+entry("proctable");
\ No newline at end of file
